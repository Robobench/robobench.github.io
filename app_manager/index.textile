---
layout: robobench_landing
title: RAPMAN: The Reproducible App Manager
description: The tool for downloading and managing Robobench Containerized Applications
---


h2. Motivation

This project began as an attempt to compile a group of demonstration applications similar to the _SPEC_ benchmarks with a focus on robotics applications and tasks. To capture a cross section of different robotics workloads, you have to install a number of different frameworks with different dependencies. To distribute these frameworks together, you need a way to distribute the code along with it's dependencies. Unfortunately, the canonical way of doing this through virtual machines. Virtual machines are generally too slow and limitted to run complex simulations well. More problematically, the result of benchmarking inside of a virtual machine are not the same as benchmarking outside of it. 

Luckily, a new virtualization technology has recently arisen which allows encapsulation of the dependencies, easy distribution, and near-native machine performance. This new form of encapsulation is called ("_containerization_"):http://en.wikipedia.org/wiki/LXC . 

To encourage adoption of this technology in the robotics community, we have created a tool for distributing robotics applications.  We hope that it will be used to make robotics software more reproducible - allowing conferences and workshops to require submissions of working simulations, helping maintain tutorials in working order, and overall adding longevity to the lifecycle of runnable, disceminable robotics software that demonstrates complex capabilities. 

h3. What Are _rapman_ Apps?

In a nutshell, rapman _apps_ are benchmarkable demos.

The purpose of the rapman manager is distributing completely encapsulated software that is configured to run and perform some simulation, demonstration, or benchmarking task.  This is not in the sense of an functional application, as the _apps_ are not meant to expose a capability for the user to use, but rather to demonstrate some capability. For example, a _navigation app_ would not expose some path planning service - rather it would run a simulation of a robot using an existing navigation capability. 

Individual _capabilities_ could be exposed through the same technique, but that would require coordination between multiple encapsulated entities, which we do not directly support as of now. 


